{"version":3,"sources":["assets/images/arrow.svg","assets/images/listener-one.svg","assets/images/stop.svg","assets/images/microphone.svg","assets/images/listening.svg","app/components/pages/exercise/listener/listener.component.tsx","app/components/pages/exercise/sentence/sentence.component.tsx","app/components/pages/exercise/actions/actions.component.tsx","app/components/services/speech-recognition-web-api.component.tsx","app/components/services/send-file-request.component.tsx","app/components/services/media-recorder.component.tsx","app/components/services/wiktionary.tsx","app/components/pages/exercise/exercise.page.tsx","app/App.tsx","serviceWorker.js","index.tsx"],"names":["module","exports","Listener","props","className","src","require","alt","Sentence","sentenceInfo","results","setWordSelected","wordSelected","phoneticValue","map","wordInfo","index","key","word","onClick","result","Actions","record","stop","isRecording","SpeechRecognitionWebApi","recognition","forceStop","finalSpeechResult","SpeechRecognition","window","speechRecognition","webkitSpeechRecognition","this","builder","Promise","resolve","reject","lang","interimResults","maxAlternatives","continuous","speechResult","start","onaudiostart","event","error","console","log","abort","join","onresult","length","transcript","toLowerCase","confidente","confidence","push","trim","split","onspeechend","onerror","onaudioend","onend","startSpeechToText","onnomatch","onsoundstart","onsoundend","onspeechstart","onstart","sendRequest","file","formData","FormData","append","config","method","body","fetch","then","res","json","data","catch","MediaRecorderWebApi","mediaRecorder","chunks","streamReference","getAudioTracks","forEach","track","navigator","mediaDevices","getUserMedia","audio","stream","MediaRecorder","state","ondataavailable","e","err","blob","Blob","type","clearChunks","File","a","mountFile","text","parseHTML","html","DOMParser","parseFromString","querySelector","textContent","getPronunciation","response","pronunciation","String","Exercise","speechToText","sentenceText","startSpeech","setState","stopSpeech","stopSpeechToText","setResult","getFinalSpeech","finalSpeech","resultValue","shift","setSentenceInfo","words","serverSpeechValidation","React","Component","App","Boolean","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","serviceWorker","ready","registration","unregister","message"],"mappings":"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","file":"static/js/main.6b5ff0c5.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/arrow.607bb7c9.svg\";","module.exports = __webpack_public_path__ + \"static/media/listener-one.2c38ffbb.svg\";","module.exports = __webpack_public_path__ + \"static/media/stop.6af5a914.svg\";","module.exports = __webpack_public_path__ + \"static/media/microphone.28cb80de.svg\";","module.exports = __webpack_public_path__ + \"static/media/listening.520d9eb6.svg\";","import React from 'react';\nimport './listener.component.css';\n\nexport default function Listener(props: any) {\n\n  return (\n      <section className=\"listener-area\">\n        <div className=\"listener-wrapper\">\n        <img \n          src={require('../../../../../assets/images/listener-one.svg')}\n          alt=\"Listener Default Expression\">\n        </img>\n\n        <div className=\"bubble\">\n          <p>That's it!</p>\n          <p>Good job!</p>\n        </div>\n        </div>\n      </section>\n  );\n}\n","import React from 'react';\nimport './sentence.component.css';\n\ntype WordInfo = {\n  word: string,\n  phoneticValue: string\n}\n\ntype SentenceProps = {\n  sentenceInfo: WordInfo[],\n  results: Boolean[],\n  setWordSelected: (wordSelected: WordInfo) => void,\n  wordSelected: WordInfo\n}\n\nexport default function Sentence(props: SentenceProps) {\n\n  const sentenceInfo = props.sentenceInfo;\n  const results = props.results;\n  const setWordSelected = props.setWordSelected;\n  const wordSelected = props.wordSelected;\n  \n  const phoneticArea = () => {\n\n    if (wordSelected.phoneticValue) {\n      return <span>{wordSelected.phoneticValue}</span>;\n    }\n    return <span className=\"unselected\"> Tap the word for more info </span>;\n  }\n\n  return (\n      <section className=\"sentence-area\">\n        <div className=\"phonetic-area\">{phoneticArea()}</div>\n        <div className=\"sentence-to-speech\">\n          {sentenceInfo.map((wordInfo, index) => {\n            return <span key={index} className={(wordSelected.word === wordInfo.word) ? \"word selected\" : \"word\"} onClick={() => setWordSelected(wordInfo)}>\n                      {wordInfo.word}\n                    </span>;\n          })}\n        </div>\n        <div className=\"result-area\">\n          {results.map((result, index) => {\n            if (result) {\n              return <span key={index} className=\"correct\"></span>;\n            }\n            else {\n              return <span key={index} className=\"incorrect\"></span>;\n            }\n          })}\n        </div>\n      </section>\n  );\n}\n","import React from 'react';\nimport './actions.component.css';\n\nexport default function Actions(props: any) {\n\n  const record = props.record;\n  const stop = props.stop;\n  const isRecording = props.isRecording;\n\n  const getButton = () => {\n    if (isRecording) {\n      return <button className=\"stop\" onClick={stop}>\n        <img\n          src={require('../../../../../assets/images/stop.svg')}\n          alt=\"Stop recording\">\n        </img>\n      </button>\n    }\n    else {\n      return <button className=\"talk\" onClick={record}>\n        <img\n          src={require('../../../../../assets/images/microphone.svg')}\n          alt=\"Start recording\">\n        </img>\n      </button>\n    }\n  }\n\n  return (\n      <section className=\"actions-area\">\n        <button className=\"arrow left\">\n          <img\n            src={require('../../../../../assets/images/arrow.svg')}\n            alt=\"Previous Exercise\">\n          </img>\n        </button>\n\n        <div className=\"center-actions\">\n          <button className=\"listen\">\n            <img\n              src={require('../../../../../assets/images/listening.svg')}\n              alt=\"Listen to example\">\n            </img>\n          </button>\n          {getButton()}\n        </div>\n\n        <button className=\"arrow right\">\n          <img\n            src={require('../../../../../assets/images/arrow.svg')}\n            alt=\"Next Exercise\">\n          </img>\n        </button>\n      </section>\n  );\n}\n","import SpeechToText from '../../../interfaces/speech-to-text';\n\nexport default class SpeechRecognitionWebApi implements SpeechToText {\n  recognition: any;\n  forceStop = false;\n  finalSpeechResult = [];\n\n  constructor() {\n    // @ts-ignore\n    const SpeechRecognition = window.speechRecognition || window.webkitSpeechRecognition;\n    if (SpeechRecognition) {\n    this.recognition = new SpeechRecognition() ;\n    this.builder();\n    }\n  }\n\n  startSpeechToText(): Promise<boolean>{\n    const promise: Promise<boolean> = new Promise((resolve, reject) => {\n\n      try {\n        this.recognition.lang = \"en-US\";\n        this.recognition.interimResults = false;\n        this.recognition.maxAlternatives = 1;\n        this.recognition.continuous = true;\n        this.recognition.speechResult = [];\n        this.recognition.start();\n\n        this.recognition.onaudiostart = (event: any) => {\n          resolve(true);\n        };\n      }\n      catch (error) {\n        console.log(error);\n        reject(false);\n      }\n    });\n\n    return promise;\n  }\n\n  stopSpeechToText() {\n    this.finalSpeechResult = this.recognition.speechResult;\n    this.forceStop = true;\n    this.recognition.abort();\n  }\n\n  getFinalSpeech() {\n    const promise:Promise<string> = new Promise(resolve => {\n      const finalSpeechResult = this.finalSpeechResult.join(\" \");\n      resolve(finalSpeechResult);\n    })\n\n    return promise;\n  }\n\n  builder() {\n    this.recognition.onresult = function (event: any) {\n      \n      const speechResult = event.results[event.results.length -1][0].transcript.toLowerCase();\n      const confidente = event.results[event.results.length -1][0].confidence\n      this.speechResult.push(...speechResult.trim().split(\" \"));\n      console.log(this.speechResult);\n\n      console.log(\"Confidence: \" + confidente);\n    };\n\n    this.recognition.onspeechend = () => {\n      this.recognition.stop();\n    };\n\n    this.recognition.onerror = (event: any) => {\n      console.log(\"Error occurred in recognition:\");\n      console.log(event); //event.error\n    };\n\n    this.recognition.onaudioend = (event: any) => {\n      //Fired when the user agent has finished capturing audio.\n      console.log(\"SpeechRecognition.onaudioend\");\n    };\n\n    this.recognition.onend = (event: any) => {\n      //Fired when the speech recognition service has disconnected.\n      console.log(\"SpeechRecognition.onend\");\n      if (this.forceStop) {\n        this.forceStop = false;\n      }\n      else {\n        this.startSpeechToText();\n        console.log(\"Starting again\");\n      }\n    };\n\n    this.recognition.onnomatch = (event: any) => {\n      //Fired when the speech recognition service returns a final result with no significant recognition. This may involve some degree of recognition, which doesn't meet or exceed the confidence threshold.\n      console.log(\"SpeechRecognition.onnomatch\");\n    };\n\n    this.recognition.onsoundstart = (event: any) => {\n      //Fired when any sound — recognisable speech or not — has been detected.\n      console.log(\"SpeechRecognition.onsoundstart\");\n    };\n\n    this.recognition.onsoundend = (event: any) => {\n      //Fired when any sound — recognisable speech or not — has stopped being detected.\n      console.log(\"SpeechRecognition.onsoundend\");\n    };\n\n    this.recognition.onspeechstart = (event: any) => {\n      //Fired when sound that is recognised by the speech recognition service as speech has been detected.\n      console.log(\"SpeechRecognition.onspeechstart\");\n    };\n\n    this.recognition.onstart = (event: any) => {\n      //Fired when the speech recognition service has begun listening to incoming audio with intent to recognize grammars associated with the current SpeechRecognition.\n      console.log(\"SpeechRecognition.onstart\");\n    };\n  }\n}\n","import ExerciseDto from \"../../../interfaces/exercise-dto\";\n\nexport function sendRequest(file: any):Promise<any> {\n\n  const formData = new FormData();\n  formData.append(\"audioData\", file);\n\n  const pathApi = \"/api\";\n  const config = {\n    method: \"POST\",\n    body: formData\n  }\n\n  const promise:Promise<ExerciseDto> = new Promise((resolve, reject) => {\n    fetch(pathApi, config)\n    .then(res => res.json())\n    .then(data => {\n      resolve(data);\n    })\n    .catch(error => {\n      reject(error);\n    });\n  });\n\n  return promise;\n}\n","import SpeechToText from '../../../interfaces/speech-to-text';\nimport { sendRequest } from './send-file-request.component';\nimport ExerciseDto from \"../../../interfaces/exercise-dto\";\n\nexport default class MediaRecorderWebApi implements SpeechToText {\n  mediaRecorder!: MediaRecorder;\n  chunks: BlobPart[];\n\n  constructor() {\n    this.chunks = [];\n  }\n\n  stopSpeechToText(): void{\n    this.mediaRecorder.stop();\n    console.log(\"recorder stopped\");\n\n    window.streamReference.getAudioTracks().forEach((track: MediaStreamTrack ) => {\n      track.stop();\n    });\n    window.streamReference = null;\n    console.log(\"recorder released\");\n    console.log(this.chunks)\n  }\n\n  startSpeechToText():Promise<boolean> {\n    console.log(\"micCue hit\");\n\n    const promise:Promise<boolean>  = new Promise((resolve, reject) => {\n      if (navigator.mediaDevices.getUserMedia) {\n        console.log(\"getUserMedia supported.\");\n  \n        this.chunks = [];\n  \n        const onSuccess = (stream: MediaStream) => {\n          window.streamReference = stream;\n          this.mediaRecorder = new MediaRecorder(window.streamReference);\n          this.mediaRecorder.start(1000);\n          console.log(this.mediaRecorder.state);\n          console.log(\"recorder started\");\n  \n          this.mediaRecorder.ondataavailable = (e: BlobEvent) => {\n            this.chunks.push(e.data);\n          };\n\n          resolve(true);\n        };\n  \n        const onError = (err: DOMException) => {\n          console.log(\"The following error occured: \" + err);\n\n          reject(false);\n        };\n  \n        navigator.mediaDevices\n          .getUserMedia({ audio: true })\n          .then(onSuccess, onError);\n      } else {\n        console.log(\"getUserMedia not supported on your browser!\");\n\n        reject(false);\n      }\n    });\n\n    return promise;\n  }\n\n  clearChunks() {\n    this.chunks = [];\n  }\n\n  mountFile() {\n    const blob = new Blob(this.chunks, { type: \"audio/webm; codecs=opus\" });\n    this.clearChunks();\n    const file = new File([blob], \"webAudio.webm\", {\n      type: \"audio/webm\"\n    });\n\n    return file;\n  }\n\n  getFinalSpeech() {\n    const promise: Promise<string> = new Promise(async (resolve, reject) => {\n\n      const file = this.mountFile();\n      const result: ExerciseDto = await sendRequest(file);\n      const text = result.text;\n      resolve(text);\n    })\n\n    return promise;\n  }\n}\n","const endpoint = \"https://en.wiktionary.org/api/rest_v1/page/html/\";\n\nconst parseHTML = (html:string) => {\n  const parser = new DOMParser();\n  const htmlDoc = parser.parseFromString(html, 'text/html');\n  const pronunciation = htmlDoc.querySelector(\".IPA\")?.textContent;\n  return pronunciation;\n}\n\nexport const getPronunciation = async (word:string) => {\n\n  const pronunciation = await fetch(endpoint+word)\n  .then(response => response.text())\n  .then(html => parseHTML(html))\n  .then(pronunciation => String(pronunciation))\n  .catch(error => {console.error(error); return \"\"}\n  );\n\n  return pronunciation;\n}\n","import React from 'react';\nimport './exercise.page.css';\n\nimport SpeechToText from '../../../../interfaces/speech-to-text';\nimport Listener from './listener/listener.component';\nimport Sentence from './sentence/sentence.component';\nimport Actions from './actions/actions.component';\nimport SpeechRecognitionWebApi from '../../services/speech-recognition-web-api.component';\nimport MediaRecorderWebApi from '../../services/media-recorder.component';\nimport { getPronunciation } from '../../services/wiktionary';\n\ntype ExerciseProps = {\n  serverSpeechValidation: boolean;\n}\n\ntype ExerciseState = {\n  results: Boolean[],\n  speechToText: SpeechToText,\n  isRecording: Boolean,\n  sentenceInfo: WordInfo[],\n  wordSelected: WordInfo\n}\n\ntype WordInfo = {\n  word: string,\n  phoneticValue: string\n}\n\nclass Exercise extends React.Component<ExerciseProps, ExerciseState> {\n\n  constructor(props: ExerciseProps) {\n    super(props);\n\n    let speechToText;\n    if (props.serverSpeechValidation) {\n      speechToText = new MediaRecorderWebApi();\n    }\n    else {\n      speechToText = new SpeechRecognitionWebApi();\n    }\n\n    this.state = {\n      results: [],\n      speechToText: speechToText,\n      isRecording: false,\n      sentenceInfo: [{word: \"loading...\", phoneticValue: \"\"}],\n      wordSelected: {word: \"\", phoneticValue: \"\"}\n    };\n  }\n\n  componentDidMount() {\n    this.setSentenceInfo();\n  }\n\n  private sentenceText = \"Nice to meet you\";\n\n  startSpeech = async () => {\n    const speechToText = this.state.speechToText;\n    const recordingStarted = await speechToText.startSpeechToText();\n\n    if (recordingStarted) {\n      const isRecording = true;\n      this.setState({ isRecording });\n    }\n  }\n\n  stopSpeech = () => {\n    const speechToText = this.state.speechToText;\n    speechToText.stopSpeechToText();\n\n    const isRecording = false;\n    this.setState({ isRecording });\n    this.setResult();\n\n  }\n\n  setResult = async () => {\n    const speechToText = this.state.speechToText;\n    const finalSpeech = await speechToText.getFinalSpeech();\n\n    console.log(\n      \"Final Speech: %c\" + finalSpeech,\n      \"font-family:system-ui;font-size:1rem;font-weight:bold\"\n    );\n\n    const expectedSentence = \"Nice to meet you\";\n    const resultValue = (finalSpeech.toLowerCase() === expectedSentence.toLowerCase() );\n\n    let results = this.state.results;\n    results.push(resultValue);\n    if (results.length > 3) {\n      results.shift();\n    }\n\n    this.setState({ results });\n  }\n\n  setSentenceInfo = async () => {\n    const sentenceText = this.sentenceText;\n    const words = sentenceText.split(\" \");\n    let sentenceInfo: WordInfo[] = [];\n\n    for (const word of words) {\n      const phoneticValue = await getPronunciation(word);\n      sentenceInfo.push({word, phoneticValue});\n    }\n\n    this.setState({ sentenceInfo });\n  }\n\n  setWordSelected = (wordSelected: WordInfo) => {\n\n    if (wordSelected.word === this.state.wordSelected.word) {\n      wordSelected = {word: \"\", phoneticValue: \"\"};\n    }\n    this.setState({ wordSelected });\n  }\n\n  render() {\n    return (\n    <div className=\"exercise-wrapper\">\n      <Listener></Listener>\n      <Sentence sentenceInfo={this.state.sentenceInfo} results={this.state.results} setWordSelected={this.setWordSelected} wordSelected={this.state.wordSelected}/>\n      <Actions record={this.startSpeech} stop={this.stopSpeech} isRecording={this.state.isRecording}/>\n    </div>);\n  }\n}\n\nexport default Exercise;\n","import React from 'react';\nimport './App.css';\nimport Exercise from './components/pages/exercise/exercise.page'\n\nfunction App() {\n  return (\n    <Exercise serverSpeechValidation={false}/>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './app/App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}